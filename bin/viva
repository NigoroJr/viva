#!/usr/bin/env ruby

require 'viva'
require 'slop'

trap(2) { exit 1 }

opts = Slop.parse do |o|
  o.bool '--add', 'Add new tracks using interactive menu'
  o.bool '--edit', 'Edit tracks using interactive menu'
  o.bool '--count', 'Count number of series and tracks in database'
  o.bool '--search', 'Search for tracks'
  o.bool '--show', 'Show track info'
  o.string '--db', 'Specify databes te use'
  o.string '--play', 'Play music (use with --save to save and play)'
  o.string '--save', 'Save file'
  o.string '-t', '--track', 'Specify track name'
  o.string '-s', '--series', 'Specify series name'

  o.bool '--scrape', 'Scrape website'
  o.bool '--rescrape', 'Clear scraped data and scrape again'

  o.bool '-h', '--help', 'Show help'
end

if opts.help?
  puts opts
  exit
end

class String
  def int?
    to_i.to_s == self
  end
end

# Prompts for an input.
# Returns the given default value if no string is entered.
def input(mes, default = :none, &validator)
  default_fmt = ' (default: %s)'
  print mes
  print format(default_fmt, default) unless default == :none || default.nil?
  print ': '
  input = STDIN.gets.chomp.strip
  input = default if input.empty? && default != :none
  return input unless block_given?

  validator.call(input) ? input : default
end

# Adds interactive functionalities to Viva class
class Viva
  def interactive_add
    what = input('Series (s) or track (t)', nil)
    return if what.nil?

    case what[0]
    when 't'
      # Expand [track_prop, raw] and make them the arguments
      db.add_track(*get_track_prop)
    when 's'
      db.add_series(get_series_prop)
    end
  end

  def interactive_edit
    what = input('Series (s) or track (t)', nil)
    return if what.nil?

    case what[0]
    when 't'
      items = interactive_search
      return if items.nil? || items.empty?
      to_edit = prompt(items)
      Viva.print_track_info(to_edit)
      puts 'Enter new information'
      (track, raw) = get_track_prop
      to_edit.update(track)
      to_edit.series = Viva::Database::Series.where(raw: raw) unless raw.nil?
      to_edit.save
    when 's'
      series = input('Search for name', nil)
      return if series.nil?
      res = db.search_series(series.split(' '))
      return if res.empty?
      to_edit = prompt(res)
      to_edit.update(get_series_prop)
      to_edit.save
    end

  end

  # Returns a list of tracks that match the query
  def interactive_search
    title = input('Title')
    series = input('Series', nil)

    return if title.empty? && series.nil?

    items = db.search_series(series.split(' ')) unless series.nil?
    # items == nil if series.nil?, which will search all tracks
    db.search_tracks(title.split(' '), nil, items)
  end

  private

  def get_track_prop
    title = input('Track title', nil)
    url = input('URL (or absolute file path', nil)
    exit 1 if url.nil?
    series = input('Series to relate', nil)
    if series.nil?
      raw = nil
    else
      candidate_series = prompt(db.search_series(series.split(' ')))
      if candidate_series.nil? || candidate_series.empty?
        puts 'Could not find that series. Adding.'
        raw = db.add_series(get_series_prop).raw
      else
        raw = candidate_series.raw
      end
    end
    track_prop = {}
    track_prop[:title] = track_prop[:default_title] = title unless title.nil?
    track_prop[:url] = url

    [track_prop, raw]
  end

  def get_series_prop
    jpn = input('Japanese name', nil)
    eng = input('English name', nil)
    exit 1 if jpn.nil? && eng.nil?
    series_prop = {}
    series_prop[:jpn] = jpn unless jpn.nil?
    series_prop[:eng] = eng unless eng.nil?
    series_prop[:raw] = jpn || eng

    series_prop
  end
end

def interactive_mode(v, action)
  case action
  when :add
    v.interactive_add
  when :edit
    v.interactive_edit
  when :search
    v.interactive_search
  end
end

# To get arguments,
args = opts.arguments

v = opts[:db].nil? ? Viva.new : Viva.new(opts[:db])

case
when opts.count?
  puts "Series: #{Viva::Database::Series.count}"
  puts "Tracks: #{Viva::Database::Track.count}"
  exit
when opts.scrape? || opts.rescrape?
  threads = input('Number of threads', 1) do |input|
    input.int? && input.to_i > 0
  end
  v.scrape(threads: threads.to_i, rescrape: opts.rescrape?)
when opts.add? || opts.edit? || (opts.search? && args.empty?)
  action = case
           when opts.add?
             :add
           when opts.edit?
             :edit
           when opts.search?
             :search
           end
  interactive_mode(v, action)
  exit
else
  case
  when opts[:series]
    tracks = if opts[:track].nil?
               series_candidates = v.db.search_series(opts[:series])
               selected = v.prompt(series_candidates)
               Viva::Database::Track.where(series_id: selected[:id])
             else
               v.db.search_tracks(opts[:track], opts[:series])
             end
  when opts[:track]
    tracks = v.db.search_tracks(opts[:track])
  else
    tracks = v.db.search(args)
  end

  exit if tracks.empty?

  to_play = v.prompt(tracks)
  exit if to_play.nil?

  if opts[:show]
    # TODO: show
    exit
  elsif !opts[:save].nil? && opts[:play].nil?
    v.save(opts[:save])
    exit
  end

  v.play(to_play, opts[:save])
end
