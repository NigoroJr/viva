#!/usr/bin/env ruby

require 'viva'
require 'slop'

trap(2) { exit 1 }

opts = Slop.parse do |o|
  o.bool '--add', 'Add new tracks using interactive menu'
  o.bool '--edit', 'Edit tracks using interactive menu'
  o.bool '--count', 'Count number of series and tracks in database'
  o.bool '--search', 'Search for tracks'
  o.bool '--show', 'Show track info'
  o.string '--db', 'Specify databes te use'
  o.string '--play', 'Play music (use with --save to save and play)'
  o.string '--save', 'Save file'
  o.string '-t', '--track', 'Specify track name'
  o.string '-s', '--series', 'Specify series name'

  o.bool '--scrape', 'Scrape website'
  o.bool '--rescrape', 'Clear scraped data and scrape again'

  o.bool '-h', '--help', 'Show help'
end

if opts.help?
  puts opts
  exit
end

class String
  def int?
    to_i.to_s == self
  end
end

# Prompts for an input.
# Returns the given default value if no string is entered.
def input(mes, default = :none, &validator)
  default_fmt = ' (default: %s)'
  print mes
  print format(default_fmt, default) unless default == :none || default.nil?
  print ': '
  input = STDIN.gets.chomp
  input = default if input.empty? && default != :none
  return input unless block_given?

  validator.call(input) ? input : default
end

def add_to_database(v)
  what = input('Series (s) or track (t)', nil)
  exit 1 if what.nil?

  case what[0]
  when 't'
    title = input('Track title')
    url = input('URL (or absolute file path', nil)
    exit 1 if url.nil?
    series = input('Series to relate', nil)
    if series.nil?
      raw = nil
    else
      raw = v.db.search_series(series.split(' ')).first.raw
    end
    track_prop = {
      title: title,
      default_title: title,
      url: url
    }
    v.db.add_track(track_prop, raw)
    puts 'Added!'
  when 's'
    jpn = input('Japanese name', nil)
    eng = input('English name', nil)
    exit 1 if jpn.nil? && eng.nil?
    series_prop = {}
    series_prop[:jpn] = jpn unless jpn.nil?
    series_prop[:eng] = eng unless eng.nil?
    series_prop[:raw] = jpn || eng
    v.db.add_series(series_prop)
    puts 'Added'
  end
end

def interactive_mode(v, action)
  case action
  when :add
    add_to_database(v)
  when :edit
    abort 'Sorry! Unimplemented!'
  when :search
    title = input('Title')
    series = input('Series', nil)

    return if title.empty? && series.nil?

    items = v.db.search_series(series.split(' ')) unless series.nil?
    items = v.db.search_tracks(title.split(' '), nil, items)

    v.print_items(items)
  end
end

# To get arguments,
args = opts.arguments

v = opts[:db].nil? ? Viva.new : Viva.new(opts[:db])

case
when opts.count?
  puts "Series: #{Viva::Database::Series.count}"
  puts "Tracks: #{Viva::Database::Track.count}"
  exit
when opts.scrape? || opts.rescrape?
  threads = input('Number of threads', 1) do |input|
    input.int? && input.to_i > 0
  end
  v.scrape(threads: threads.to_i, rescrape: opts.rescrape?)
when opts.add? || opts.edit? || (opts.search? && args.empty?)
  action = case
           when opts.add?
             :add
           when opts.edit?
             :edit
           when opts.search?
             :search
           end
  interactive_mode(v, action)
  exit
else
  case
  when opts[:series]
    tracks = if opts[:track].nil?
               series_candidates = v.db.search_series(opts[:series])
               selected = v.prompt(series_candidates)
               Viva::Database::Track.where(series_id: selected[:id])
             else
               v.db.search_tracks(opts[:track], opts[:series])
             end
  when opts[:track]
    tracks = v.db.search_tracks(opts[:track])
  else
    tracks = v.db.search(args)
  end

  exit if tracks.empty?

  to_play = v.prompt(tracks)
  exit if to_play.nil?

  if opts[:show]
    # TODO: show
    exit
  elsif !opts[:save].nil? && opts[:play].nil?
    v.save(opts[:save])
    exit
  end

  v.play(to_play, opts[:save])
end
